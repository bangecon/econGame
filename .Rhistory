ifelse(Partner.Strategy == "Collude",
profit(c(ql.d, qi.c)),
profit(c(ql.d, qf.dd)))
)
)
})
if (nrow(followerResults) > 0) {
followerResults <- within(followerResults, {
Q.Partner <- ifelse(Partner.Strategy == "Collude", qi.c, ql.d)
Q.Student <- ifelse(Strategy == "Collude",
qi.c,
ifelse(Partner.Strategy == "Collude", qf.dc, qf.dd))
Profit <- ifelse(
Partner.Strategy == "Collude",
ifelse(Strategy == "Collude",
profit(c(qi.c, qi.c)),
profit(c(qi.c, qf.dc))),
ifelse(Strategy == "Collude",
profit(c(ql.d, qi.c)),
profit(c(ql.d, qf.dd)))
)
})
}
results <- rbind(leaderResults, followerResults)
View(results)
outcomes <- paste0(leaderResults$Strategy, "-", leaderResults$Partner.Strategy)
grades <-
aggregate(Profit ~ First.Name + Last.Name,
data = results,
FUN = sum)
tree <-
gameTree(
players = c("Leader", "Follower"),
payoffs1 = leaderPayoffs,
payoffs2 = followerPayoffs
)
colnames(grades) <- c("Last Name", "First Name", "Score")
out <- list(
type = "stackelbergGame",
payoff = cbind(leaderPayoffs, followerPayoffs),
tree = tree,
leaderResults,
followerResults,
outcomes = outcomes,
results = results[order(results$Round,
results$Last.Name,
results$First.Name), -which(names(results) %in% 'Timestamp')],
grades = grades[order(grades$`Last Name`, grades$`First Name`), ]
)
class(out) <- c('econGame', class(out))
out
library(shiny)
devtools::document()
sheet
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
devtools::document()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
runStackelbergGameApp()
devtools::document()
runStackelbergGameApp()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
results <- read_sheet('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
subset(results, Role == "Leader")
devtools::document()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
devtools::document()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
runStackelbergGameApp()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')$outcomes
devtools::document()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')$outcomes
plot(stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI'))
class(stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')$outcomes)
devtools::document()
plot(stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI'))
plot(stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI'))
devtools::document()
plot(stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI'))
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')$outcomes
devtools::document()
plot(stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI'))
runStackelbergGameApp()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
devtools::document()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
runStackelbergGameApp()
stackelbergGame('1nZFzrvIwqdl0cXpBDZojAeJ1DgGDhSQ_kvyT8dW2zLI')
runStackelbergGameApp()
devtools::document()
install.packages("rticles")
unlink("docs/marketGame_cache", recursive = TRUE)
devtools::document()
runEquilibriumGameApp()
sheet = '17di0Lx2UDlZmak46Suwb5WXHhrQo0_LOmekvOoCoaKw'
rm(loop_id, runAll, timeoutSecs)
rm(find_optimum())
rm(find_optimum
)
sheet = '17di0Lx2UDlZmak46Suwb5WXHhrQo0_LOmekvOoCoaKw'
results <- read_sheet(sheet)
colnames(results) <- make.names(colnames(results))
results <-
replace_na(results, list(First.Name = "John", Last.Name = "Doe"))
results$First.Name <- str_to_title(results$First.Name)
results$Last.Name <- str_to_title(results$Last.Name)
results$qi <- 1
results$Price <- NULL
rounds <- max(results$Round)
schedules <- list(NULL)
equilibria <- list(NULL)
schedules[[i]] <-
as.data.frame(matrix(
nrow = 10,
ncol = 3,
dimnames = list(NULL, c('Price', 'Demand', 'Supply'))
))
schedules[[i]]$Price <- c(1:10)
roundresult <- subset(results, Round == i)
responses <- nrow(roundresult)
for (j in 1:10) {
schedules[[i]]$Demand[j] <- nrow(subset(roundresult, Bid >= j))
schedules[[i]]$Supply[j] <-
nrow(subset(roundresult, Ask <= j))
}
# Calculate the equilibrium for each round
equilibria[[i]] <-
as.data.frame(
find_optimum(
roundresult$Ask,
roundresult$qi,
roundresult$Bid,
roundresult$qi
)
)
}
i = 1
schedules[[i]] <-
as.data.frame(matrix(
nrow = 10,
ncol = 3,
dimnames = list(NULL, c('Price', 'Demand', 'Supply'))
))
schedules[[i]]$Price <- c(1:10)
roundresult <- subset(results, Round == i)
responses <- nrow(roundresult)
for (j in 1:10) {
schedules[[i]]$Demand[j] <- nrow(subset(roundresult, Bid >= j))
schedules[[i]]$Supply[j] <-
nrow(subset(roundresult, Ask <= j))
}
# Calculate the equilibrium for each round
equilibria[[i]] <-
as.data.frame(
find_optimum(
roundresult$Ask,
roundresult$qi,
roundresult$Bid,
roundresult$qi
)
)
}
Rcpp::sourceCpp(
code = '
#include <Rcpp.h>
#include <map>
// [[Rcpp::export]]
Rcpp::List find_optimum(Rcpp::NumericVector price_supply,
Rcpp::NumericVector quant_supply,
Rcpp::NumericVector price_demand,
Rcpp::NumericVector quant_demand) {
std::map<double, double> supply;
std::map<double, double> demand;
// fill the maps
for (int i = 0; i < price_supply.size(); ++i) {
supply[price_supply[i]] += quant_supply[i];
}
for (int i = 0; i < price_demand.size(); ++i) {
demand[price_demand[i]] += quant_demand[i];
}
if (supply.empty() || demand.empty())
return Rcpp::List::create(Rcpp::Named("price") = 0,
Rcpp::Named("quantity") = 0);
auto sIt = supply.begin(), nextS = std::next(sIt, 1);
const auto endS = supply.end();
auto dIt = demand.rbegin(), nextD = std::next(dIt, 1);
const auto endD = demand.rend();\
// quantity and prices at either side
double pS = sIt->first, pD = dIt->first;
double qS = 0, qD = 0;
// next prices
double nextPS = nextS->first, nextPD = nextD->first;
if (pD < pS)
return Rcpp::List::create(Rcpp::Named("price") = 0, Rcpp::Named("quantity") = 0);
// add the best price from each side!
qS += sIt->second;
qD += dIt->second;
while (pS < pD) {
if (nextS == endS && nextD == endD) {
pD = qD < qS ? pS : pD;
break;
}
while (qS <= qD && sIt != endS && nextS->first <= pD) {
++sIt;
++nextS;
pS = sIt->first;
qS += sIt->second;
}
if (sIt == endS) break;
if (nextD->first < pS) {
pD = qD < qS ? pS : pD;
break;
}
while (qD < qS && dIt != endD && nextD->first >= pS) {
++dIt;
++nextD;
pD = dIt->first;
qD += dIt->second;
}
if (dIt == endD) break;
}
double price = pD;
double vol = qS < qD ? qS : qD;
return Rcpp::List::create(Rcpp::Named("price") = price,
Rcpp::Named("quantity") = vol);
}
)
Rcpp::sourceCpp(
code = '
#include <Rcpp.h>
#include <map>
// [[Rcpp::export]]
Rcpp::List find_optimum(Rcpp::NumericVector price_supply,
Rcpp::NumericVector quant_supply,
Rcpp::NumericVector price_demand,
Rcpp::NumericVector quant_demand) {
std::map<double, double> supply;
std::map<double, double> demand;
// fill the maps
for (int i = 0; i < price_supply.size(); ++i) {
supply[price_supply[i]] += quant_supply[i];
}
for (int i = 0; i < price_demand.size(); ++i) {
demand[price_demand[i]] += quant_demand[i];
}
if (supply.empty() || demand.empty())
return Rcpp::List::create(Rcpp::Named("price") = 0,
Rcpp::Named("quantity") = 0);
auto sIt = supply.begin(), nextS = std::next(sIt, 1);
const auto endS = supply.end();
auto dIt = demand.rbegin(), nextD = std::next(dIt, 1);
const auto endD = demand.rend();\
// quantity and prices at either side
double pS = sIt->first, pD = dIt->first;
double qS = 0, qD = 0;
// next prices
double nextPS = nextS->first, nextPD = nextD->first;
if (pD < pS)
return Rcpp::List::create(Rcpp::Named("price") = 0, Rcpp::Named("quantity") = 0);
// add the best price from each side!
qS += sIt->second;
qD += dIt->second;
while (pS < pD) {
if (nextS == endS && nextD == endD) {
pD = qD < qS ? pS : pD;
break;
}
while (qS <= qD && sIt != endS && nextS->first <= pD) {
++sIt;
++nextS;
pS = sIt->first;
qS += sIt->second;
}
if (sIt == endS) break;
if (nextD->first < pS) {
pD = qD < qS ? pS : pD;
break;
}
while (qD < qS && dIt != endD && nextD->first >= pS) {
++dIt;
++nextD;
pD = dIt->first;
qD += dIt->second;
}
if (dIt == endD) break;
}
double price = pD;
double vol = qS < qD ? qS : qD;
return Rcpp::List::create(Rcpp::Named("price") = price,
Rcpp::Named("quantity") = vol);
}
'
)
i=1
# Set up the Google Sheets, read responses, and initialize output objects.
results <- read_sheet(sheet)
colnames(results) <- make.names(colnames(results))
results <-
replace_na(results, list(First.Name = "John", Last.Name = "Doe"))
results$First.Name <- str_to_title(results$First.Name)
results$Last.Name <- str_to_title(results$Last.Name)
results$qi <- 1
results$Price <- NULL
rounds <- max(results$Round)
schedules <- list(NULL)
equilibria <- list(NULL)
for (i in 1:rounds) {
# Create the supply and demand schedules for each round
schedules[[i]] <-
as.data.frame(matrix(
nrow = 10,
ncol = 3,
dimnames = list(NULL, c('Price', 'Demand', 'Supply'))
))
schedules[[i]]$Price <- c(1:10)
roundresult <- subset(results, Round == i)
responses <- nrow(roundresult)
for (j in 1:10) {
schedules[[i]]$Demand[j] <- nrow(subset(roundresult, Bid >= j))
schedules[[i]]$Supply[j] <-
nrow(subset(roundresult, Ask <= j))
}
# Calculate the equilibrium for each round
equilibria[[i]] <-
as.data.frame(
find_optimum(
roundresult$Ask,
roundresult$qi,
roundresult$Bid,
roundresult$qi
)
)
}
# Calculate student points.
results$Price <- NA
for (i in 1:nrow(results)) {
results$Price[i] <- equilibria[[results$Round[i]]]$price
}
results$Points <-
I(results$Bid >= results$Price) * (results$Value - results$Price) +
I(results$Ask <= results$Price) * (results$Price - results$Value)
grades <-
aggregate(
Points ~ Last.Name + First.Name,
data = results,
FUN = sum,
na.action = na.pass
)
out <- list(
type = "equilibriumGame",
results = results[order(results$Round,
results$Last.Name,
results$First.Name),],
rounds = rounds,
schedules = schedules,
equilibria = equilibria,
grades = grades[order(grades$Last.Name, grades$First.Name),]
)
equilibriumGame(sheet = sheet)
runEquilibriumGameApp()
runEquilibriumGameApp()
plot(equilibriumGame(sheet = sheet))
plot(equilibriumGame(sheet = sheet), round = 1)
equilibriumGame(sheet = sheet)$schedule[[1]]
equilibriumGame(sheet = sheet)$grades
equilibriumGame(sheet = sheet)$results
subset(equilibriumGame(sheet = sheet)$results, Round == 1)
data.frame(subset(equilibriumGame(sheet = sheet)$results, Round == 1))
devtools::document()
runEquilibriumGameApp()
spring2022.1 <- equilibriumGame(sheet = sheet)
plot(spring2022.1)
spring2022.1$grades
devtools::document()
runEquilibriumGameApp()
devtools::document()
runEquilibriumGameApp()
devtools::document()
runEquilibriumGameApp()
runUltimatumGameApp()
runAnchoringGameApp()
library(readr)
DemandData <- read_csv("D:/Google Drive/Teaching/PrinciplesOfMicro(Spring2022)/Streamlined202ProjectApp/DemandData.csv")
View(DemandData)
library(corrgram)
corrgram(DemandData)
panel.raters <- function (x, y, corr = NULL, col.regions, cor.method, ...) {
if (!is.null(corr))
return()
plot.xy(xy.coords(x, y), type = "p", ...)
lines(smooth.spline(x, y, spar = 1))
box(col = "lightgray")
}
corrgram(DemandData, lower.panel = panel.raters, upper.panel = panel.cor, diag.panel = panel.density)
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`)
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer")
abline(lm(`Price of Beer` ~ `Quantity of Beer`, data = DemandData))
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer")
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", color = 'red')
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
warnings()
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
points(q.adj, p.adj, col = 'blue')
q.resid <- lm(`Quantity of Beer` ~ `Price of Liquor` + `Price of Related Goods` + `Income`,
data = DemandData)
p.resid <- lm(`Price of Beer` ~ `Price of Liquor` + `Price of Related Goods` + `Income`,
data = DemandData)
q.adj <- mean(DemandData$`Quantity of Beer`) + q.resid
p.adj <- mean(DemandData$`Price of Beer`) + q.resid
mean(DemandData$`Quantity of Beer`)
mean(DemandData$`Quantity of Beer`) + q.resid
q.resid
q.resid$residuals
q.resid <- lm(`Quantity of Beer` ~ `Price of Liquor` + `Price of Related Goods` + `Income`,
data = DemandData)$residuals
p.resid <- lm(`Price of Beer` ~ `Price of Liquor` + `Price of Related Goods` + `Income`,
data = DemandData)$residuals
q.adj <- mean(DemandData$`Quantity of Beer`) + q.resid
p.adj <- mean(DemandData$`Price of Beer`) + q.resid
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
abline(lm(`Price of Beer` ~ `Quantity of Beer`, data = DemandData))
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
abline(lm(`Price of Beer` ~ `Quantity of Beer`, data = DemandData), col = 'red')
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
abline(lm(`Price of Beer` ~ `Quantity of Beer`, data = DemandData))
points(q.adj, p.adj, col = 'blue')
abline(q.adj, p.adj, col = 'blue')
q.resid <- lm(`Quantity of Beer` ~ `Price of Liquor` + `Price of Related Goods` + `Income`,
data = DemandData)$residuals
p.resid <- lm(`Price of Beer` ~ `Price of Liquor` + `Price of Related Goods` + `Income`,
data = DemandData)$residuals
q.adj <- mean(DemandData$`Quantity of Beer`) + q.resid
p.adj <- mean(DemandData$`Price of Beer`) + p.resid
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
abline(lm(`Price of Beer` ~ `Quantity of Beer`, data = DemandData), col = 'red')
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
abline(lm(`Price of Beer` ~ `Quantity of Beer`, data = DemandData))
points(q.adj, p.adj, col = 'blue')
abline(q.adj, p.adj, col = 'blue')
abline(lm(q.adj ~ p.adj), col = 'blue')
lm(q.adj ~ p.adj
)
abline(lm(p.adj ~ q.adj), col = 'blue')
plot(DemandData$`Quantity of Beer`, DemandData$`Price of Beer`, xlab = "Quantity of Beer", ylab = "Price of Beer", col = 'red')
abline(lm(`Price of Beer` ~ `Quantity of Beer`, data = DemandData), col = 'red')
points(q.adj, p.adj, col = 'blue')
abline(lm(p.adj ~ q.adj), col = 'blue')
devtools::document()
runAnchoringGameApp()
runUltimatumGameApp()
runAnchoringGameApp()
devtools::document()
runEntryGameApp()
runEntryGameApp()
runCournotGameApp()
devtools::document()
runCournotGameApp()
runCournotGameApp()
devtools::document()
runCournotGameApp()
runBertrandGameApp()
runStackelbergGameApp()
devtools::document()
runEntryGameApp()
entryGame('1IM-zk5NJ_U4yPgKSlqtmiBUlZ9knXSsLSgU2AjLWnbI')
sheet <- '1IM-zk5NJ_U4yPgKSlqtmiBUlZ9knXSsLSgU2AjLWnbI'
results <- read_sheet(sheet)
colnames(results) <- make.names(colnames(results))
devtools::document()
runLobbyGameApp()
devtools::document()
runEconGameApp()
runBertrandGameApp()
runCournotGameApp()
runBertrandGameApp()
runCournotGameApp()
runBertrandGameApp()
runBertrandGameApp()
runCournotGameApp()
devtools::document()
runEquilibriumGameApp()
runEquilibriumGameApp()
.libPaths()
run_tutorial("hello", "learnr")
gc()
devtools::document()
runUltimatumGameApp()
runUltimatumGameApp()
devtools::document()
runEntryGameApp('1aF8vLLSTnR722gpti2uqMkHDyUZfoA9Zw471g7Jknjk')
runEntryGameApp()
entryGame('1aF8vLLSTnR722gpti2uqMkHDyUZfoA9Zw471g7Jknjk')
devtools::document()
runEquilibriumGameApp()
gs4_token()
gs4_deauth()
gs4_has_token()
runEquilibriumGameApp()
runEntryGameApp()
entryGame('1aF8vLLSTnR722gpti2uqMkHDyUZfoA9Zw471g7Jknjk')
entryResults = entryGame('1aF8vLLSTnR722gpti2uqMkHDyUZfoA9Zw471g7Jknjk')
help(plot.econGame)
plot(entryResults)
plot(entryResults, nrow = 5)
plot(entryResults, nrow = 2)
plot(entryResults, nrow = 1)
plot(entryResults, nrow = 3)
plot(entryResults, round = 1)
plot(entryResults)
